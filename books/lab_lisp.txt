ЛАБОРАТОРНАЯ РАБОТА  N 1

                        РАБОТА СО СПИСКАМИ

ЦЕЛЬ РАБОТЫ: изучение функций для работы со списками, изучение ме-
тодов  обработки  списков с использованием рекурсии,  приобретение
навыков написания функций для работы со списками.

                        Постановка задачи

     Списки являются   основными   типами   данных   языка    Лисп
[1-6,10,11].  Под  списком  понимается конечная последовательность
элементов списка,  заключенная в круглые скобки.  Элементом списка
может быть либо атом,  либо список.  Первый элемент списка называ-
ется головой списка,  а остаток списка (без  первого  элемента)  -
хвостом списка.  Атомом называется произвольная последовательность
букв и цифр,  заключенная между двумя ограничителями  языка  Лисп.
Литеральный атом часто называется символом. В языке Лисп определе-
ны два стандартных атома T и NIL,  выполняющие роль понятий ИСТИНА
и ЛОЖЬ.  Строго говоря, числа в Лиспе также являются атомами. При-
мер списка:  (А (B (C))). Данный список состоит из двух элементов:
атома A и списка (B (C)),  который в свою очередь состоит из атома
A и списка (C). Пустой список - это список, не содержащий ни одно-
го  элемента.  Он обозначается () или атомом NIL.  Пустой список в
Лиспе относится к атомам.
     Список представляет собой ссылочную структуру.  Основная ссы-
лочная структура языка - так  называемая  точечная  пара,  которая
состоит из указателей на первый и второй элементы пары.  Так, нап-
ример,  точечная пара с указателями на атомы A и B изображается  в
символьной нотации как (A.B). Если точечная пара первым указателем
ссылается на атом A,  а вторым - на другую точечную пару (B.C), то
это изображается в символьной нотации как (A.(B.C)).
     Список (A B C D) в точечной нотации будет иметь следующий вид:
                   (A.(B.(C.(D.NIL)))).
     Под S-выражением в языке  Лисп  понимается  либо  атом,  либо
список.  В языке Лисп с точки зрения синтаксиса программы и данные
не различаются. Любое S-выражение Лиспа можно интерпретировать как
программу. Интерпретацию S-выражений выполняет функция EVAL. Одна-
ко не любое S-выражение может быть удачно  интерпретировано  из-за
семантических соображений.  Можно выделить некоторые общие правила
интерпретации S-выражений:
     1) Если S-выражение является числом или атомом T или NIL,  то
EVAL возвращает это S-выражение без изменений;
     2) Если  S-выражение является литеральным атомом,  то функция
EVAL возвращает последнее значение,  которое было присвоено  этому
атому, в противном случае возвращается сообщение об ошибке;
     3) Если S-выражение представляет собой список  вида
(f arg1 arg2 ...  argN), то функция EVAL пытается интерпретировать
его следующим образом:  первый элемент списка интерпретируется как
имя функции,  которую необходимо выполнить,  взяв в качестве аргу-
ментов оставшиеся элементы списка arg1,  arg2,...,argN.  В  случае
удачи функция EVAL возвращает S-выражение,  являющееся результатом
выполнения функции f.  Функция f может быть встроенной или опреде-
ленной пользователем.
     В некоторых случаях не надо вычислять значение  выражения,  а
нужно само выражение.  Чтобы предотвратить вычисление значения вы-
ражения,  нужно перед этим выражением поставить апостроф '. Апост-
роф  перед  выражением  -  это на самом деле сокращение лисповской
формы (QUOTE <выражение>),  где QUOTE - специальная функция, кото-
рая возвращает невычисленный аргумент <выражение>.
 > '(+ 2 3)
 (+ 2 3)
 > (+ 2 3)
 5
     Здесь и ниже в примерах знак ">" означает приглашение интерп-
ретатора  Xlisp.  После  данного знака набирается интерпретируемое
выражение. Ответ интерпретатора представляется на второй строке.
     Базисными функциями обработки S-выражений являются: CAR, CDR,
CONS, ATOM и EQ.
     Вызов функции CAR:  (CAR <список>).  Функция CAR возвращает в
качестве значения первый (головной) элемент списка-аргумента.  Тип
результата - S-выражение.
 > (CAR '((1 2) 3))
 (1 2)
     Вызов функции CDR:  (CDR <список>).  Функция CDR возвращает в
качестве значения хвостовую часть списка-аргумента. Тип результата
- список.
 > (CDR '((1 2) 3))
 (3)
 > (CDR 'A)
 NIL
     Функции CAR  и CDR позволяют добраться до любого элемента лю-
бого списка.  Например, до второго элемента списка можно добраться
с использованием следующего S-выражения: (CAR (CDR <список>)).
 > (CAR (CDR '(1 2 3 4)))
 2
     Для композиции функций CAR и CDR введены специальные  обозна-
чения.  В Xlisp это - CxxR, CxxxR, CxxxxR, где x - это буква A или
D. Например, вызов (CADR X) эквивалентен вызову (CAR (CDR X)).
 > (CADR '(1 2 3 4))
 2
     Функция CONS (construct) строит новый список из переданных ей
в качестве аргументов головы (S-выражение) и хвоста (списка):
          (CONS <голова списка><хвост списка>).
 > (CONS 'A '(B C))
 (A B C)
 > (CONS '(A B) '(C D))
 ((A B) C D)
     Предикат ATOM проверяет,  является ли аргумент атомом.  Аргу-
ментом  может быть любое S-выражение.  Значение предиката равно T,
если значение аргумента - атом,  и NIL, когда значение аргумента -
не атом.
 > (ATOM 'X)
 T
     Предикат EQ проверяет тождественность двух символов. Предикат
EQ принимает значение T, если символы идентичны, и значение NIL во
всех других случаях, включая случаи, когда аргументами являются не
символы.
 > (EQ (CAR '(A A))(CAR '(A B C D)))
 T
     Более общим по сравнению с EQ является предикат EQL,  который
дополнительно  позволяет  сравнивать  однотипные  числа  и строки.
Обобщением EQL является предикат EQUAL, позволяющий проверять оди-
наковость двух списков:
 > (EQUAL '(X Y Z) '(X Y Z))
 T
     Основными функциями,   изменяющими    физическую    структуру
списков, являются RPLACA (replace CAR) и RPLACD (replace CDR):
       (RPLACA <список><выражение>)
       (RPLACD <список><выражение>)
     Функция RPLACA заменяет  первый  элемент  списка,  а  функция
RPLACD - остаток списка значением выражения. Обе функции возвраща-
ют список после его изменения.
     Условные выражения  в  Лиспе обычно строятся с использованием
функции COND. Структура условного выражения такова:
    (COND (p1 e1) (p2 e2)...(pN eN)),
где p1,p2,...,pN - предикаты,  а e1,e2,...,eN -  произвольные  ре-
зультирующие выражения.
     Значение функции COND определяется следующим образом:
     1. Вычисляются последовательно слева направо значения выраже-
ний pi до тех пор, пока не встретится выражение, значение которого
отлично от NIL, что интерпретируется как ИСТИНА.
     2. Вычисляется результирующее выражение, соответствующее это-
му предикату, и полученное значение возвращается в качестве значе-
ния функции COND.
     3. Если истинного предиката нет, то значением COND будет NIL.
     В условном выражении может отсутствовать результирующее выра-
жение  pi или на его месте часто может быть последовательность вы-
ражений: (COND (p1 e11)...(pi)...(pk ek2...ekn)...).
     Если условию  не ставится в соответствие результирующее выра-
жение,  то в качестве результата предложения COND  при  истинности
предиката выдается само значение предиката.  Если же условию соот-
ветствует несколько выражений, то при его истинности выражения вы-
числяются последовательно слева направо и результатом функции COND
будет значение последнего выражения последовательности.
      Символы в языке Лисп могут иметь значения. Изначально у сим-
волов нет какого-либо значения.  Значения  символам  присваиваются
при помощи псевдофункций (иначе, функций с побочным эффектом, при-
чем основным действием и является этот побочный эффект) SET, SETQ,
SETF.  Вызов функции SETQ имеет следующий вид: (SETQ <sym><expr>),
где <sym> - символ (не вычисляется), <expr> - выражение, описываю-
щее  новое значение символа.  Функция возвращает значение символа.
Функция SET аналогична функции SETQ,  но в отличие от последней ее
аргумент не вычисляется.
 > (SETQ A 'B)
 B
 > (SET A 7)
 7
 > B
 7
     Наряду со значением любой символ в  языке  Лисп  может  иметь
специальный  присоединенный  список,  называемый  списком свойств.
Структура этого списка:  (p1 v1 p2 v2 ... pn vn), где p1,p2,...,pn
- атомы, обозначающие имена свойств (называемые иногда индикатора-
ми),  v1,v2,...,vn - S-выражения,  соответствующие значениям  этих
свойств.  Выяснить значение свойства, связанного с символом, можно
с помощью функции GET: (GET <символ><свойство>).
     Присваивание нового свойства или изменение значения существу-
ющего свойства осуществляется псевдофункцией PUTPROP:
       (PUTPROP <символ><свойство><значение>).
     Удаление свойства и его значения осуществляется псевдофункци-
ей REMPROP: (REMPROP <символ><свойство>).
     Ассоциативным списком (а-списком) в Лиспе  называется  список
точечных пар вида: ((k1.v1)(k2.v2)...(kn.vn)). Первый элемент пары
называется ключем, а второй - связанными с ключем данными. Функция
ASSOC   ищет   пару,  соответствующую  ключу  в  а-списке:
(ASSOC <ключ><a-список>).  Поиск ведется от первой пары  списка  к
последней. Функция ACONS добавляет новую пару в начало списка.
     Определить новую функцию в языке Лисп можно с помощью функции
DEFUN:
 (DEFUN <sym> (<arg1><arg2>...<argN>)<expr1><expr2>...<exprM>),
где <sym> - имя определяемой функции, <arg1><arg2>...<argN> - ато-
мы,  используемые  для  указания  формальных  аргументов  функции,
<expr1><expr2>...<exprM>  -  любые S-выражения,  составляющие тело
функции. Функция возвращает символ <sym>. Для определения неимено-
ванных функций в Лиспе используются LAMBDA-выражения.
     Ввод в интерпретатор определений функций и их  вызовов  может
осуществляться  как  с  командной строки интерпретатора,  так и из
файла. Для последнего случая предусмотрена системная функция LOAD:
(LOAD  <имя файла>).  Читаемые из файла выражения выполняются так,
как будто бы они были введены пользователем. В Xlisp <имя файла> -
это  строчное  имя  файла или символ (со строчным значением).  При
этом под именем файла  подразумевается  путь  к  файлу,  описанный
средствами MS DOS,  причем символ "/" в пути удваивается.  Функция
LOAD возвращает T в случае,  если файл удачно загружен,  и NIL - в
противном случае:
 > (LOAD "c:\\xlisp\\trace.lsp").
 T
     Функция является рекурсивной,  если в ее  определении  содер-
жится  вызов самой этой функции.  Рекурсия является простой,  если
вызов функции встречается в некоторой ветви лишь один раз. Простой
рекурсии в процедурном программировании соответствует обыкновенный
цикл.  Соответствующие вложенным  циклам  многократные  повторения
осуществляются  обычно  с помощью двух и более функций,  каждая из
которых соответствует простому циклу.  В  рекурсивном  определении
существенен порядок следования условий.  Правильную последователь-
ность можно получить путем логического рассуждения на основе учета
возможных  ситуаций.  При  определении  порядка следования условий
основным моментом является то, что сначала проверяются все возмож-
ные условия окончания, а затем ситуации, требующие продолжения вы-
числений.  Отсутствие проверки,  ошибочное условие или неверный их
порядок могут привести к бесконечной рекурсии.
     В качестве примера использования рекурсии рассмотрим функции,
реализующие пересечение двух множеств, представленных списками.
  (defun belongs (elem list)
     (cond ((null list) NIL)
           ((eq elem (car list)) T)
           (T (belongs elem (cdr list)))))
  (defun intersect (list1 list2)
     (cond ((null list2) NIL)
           ((belongs (car list2) list1)
                 (cons (car list2)(intersect list1 (cdr list2))))
           (T (intersect list1 (cdr list2)))))
     Первая из  приведенных функций (belongs) используется для оп-
ределения,  принадлежит ли элемент elem списку list. Функция возв-
ращает T - если принадлежит,  и NIL - иначе. Таким образом, данная
функция является предикатом.
 > (BELONGS 'B '(A B C D))
 T
     Тело функции belongs состоит из условного предложения,  имею-
щего три ветви:
     1) Если список list пустой (определяется предикатом null), то
возвращается значение NIL.  Данный список может быть пустым либо с
самого начала, либо потому, что просмотр списка окончен.
     2) Если первым элементом списка list является искомый элемент
elem, то возвращается T.
     3) Ни одно из предыдущих утверждений не верно: в таком случае
либо  элемент  содержится в хвосте списка,  либо вовсе не входит в
список.  Для продолжения решения задачи применяем тот же  предикат
belongs к хвосту списка.  Таким образом, задача свелась к прежней,
но на шаг более короткой.
     Вторая функция  (intersect) формирует список-результат из тех
элементов,  которые входят в список list1  и  list2  одновременно.
Функция  intersect состоит из условного предложения,  имеющего три
ветви:
     1) Если список list2 пуст, то возвращается NIL.
     2) Если первый элемент списка list2 принадлежит списку list1,
то  этот  элемент  включается  как  голова результирующего списка.
Хвост данного списка формируется как результат пересечения  списка
list1 и хвоста списка list2.
     3) Ни одно из предыдущих условий не верно.  В этом случае ре-
зультирующий  список  получается  как результат пересечения списка
list1 и хвоста списка list2.
 > (INTERSECT '(A B C D) '(X D E C))
 (C D)
     Для отладки   Лисп-программы  следует  использовать  средства
трассировки.  Трассировка какой-либо в Xlisp включается при помощи
функции TRACE: (TRACE '<имя функции>).
  > (TRACE 'INTERSECT)
  TRACE
     После ввода директивы TRACE интерпретатор будет распечатывать
имя  функции  и  значения  аргументов  каждого вызова трассируемой
функции и полученный результат после окончания вычисления  каждого
вызова.  Трассировку можно отключить аналогичной по форме директи-
вой UNTRACE.

                  ВАРИАНТЫ ЗАДАНИЙ НА ВЫПОЛНЕНИЕ

     Ниже приводятся спецификации функций, которые необходимо реа-
лизовать на языке Лисп.  Вариант,  помеченный символом *, включает
два подварианта: подвариант а) - действия функции распространяются
только на список верхнего уровня;  подвариант б) - рассматриваются
подсписки всех уровней (замечание:  во втором случае  использовать
рекурсию  как по хвостам,  так и по головам списков).  Приведенные
функции для удобства разбиты по темам.

                     A) Операции над списками

     1) Функция COPY - создает в списочной памяти второй экземпляр
произвольного S-выражения.
     2) Функция LENGTH -  возвращает  в  качестве  значения  длину
списка [*].
     3) Функция APPEND - соединяет два списка в один новый список.
     4) Функция  REMOVE - удаляет из списка все совпадающие с дан-
ным атомом элементы и возвращает в  качестве  значения  список  из
всех оставшихся элементов [*].
     5) Функция REMOVEF - удаляет из списка первые вхождения  дан-
ного элемента [*].
     6) Функция REMOVEL - удаляет из списка последний элемент [*].
     7) Функция SUBSTITUE - заменяет все вхождения данного элемен-
та в списке на новый элемент [*].
     8) Функция  REVERSE  - изменяет порядок элементов в списке на
обратный [*].
     9) Функция  FIRST-ATOM  - результатом функции является первый
атом списка (в учет принимаются списки всех уровней).
     10) Функция LAST - возвращает последний элемент списка.
     11) Функция ADDIFNONE -  проверяет,  содержится  ли  заданный
элемент  (значение  первого аргумента) в заданном списке (значение
второго аргумента), и если нет, то добавляет этот элемент к списку
[*].
     12) Функция  COLLECT  -  перегруппирует  элементы   заданного
списка  так,  чтобы  одинаковые элементы,  если они есть в списке,
стояли все подряд [*].
     13) Функция  FLATTEN  -  устраняет в произвольном S-выражении
все внутренние скобки,  а в точечных выражениях - и точки, превра-
щая его в список атомов. Количество и относительный порядок атомов
в выражении сохраняются.
     14) Функция REVL - обращает список и разбивает его на уровни.
Пример:  исходный список - (a b c),  результирующий список -
(((c) b) a).
     15) Функция DEVLEV1 - разбивает  список  на  уровни.  Пример:
исходный список - (a b c), результирующий список - (a (b (c))).
     16) Функция DEVLEV2 - разбивает  список  на  уровни.  Пример:
исходный список - (a b c), результирующий список - (((a) b) c).
     17) Функция DESTLEV1  -  убирает  уровни  в  списке.  Пример:
исходный список - (a (b (c))), результирующий список - (a b c).
     18) Функция DESTLEV2  -  убирает  уровни  в  списке.  Пример:
исходный список - (((a) b) c), результирующий список - (a b c).
     19) Функция REMSEC - удаляет из списка каждый второй  элемент
[*].
     20) Функция DEVPAIR  -  разбивает  список  на  пары.  Пример:
исходный список - (a b c d ...),  результирующий список -
((a b)(c d)...).
     21) Функция MIX - чередует элементы двух списков-аргументов и
образует новый список.  Пример: исходные списки - (a b ...) и
(1 2 ...), результирующий список - (a 1 b 2 ...).
     22) Функция DEPTH - вычисляет глубину списка (самой  глубокой
ветви).

                  B) Функции с побочным эффектом

     1) Функция ATTACH - вырабатывает то же значение,  что и CONS,
но, в отличие от CONS, она заставляет обладать этим значением свой
второй аргумент.
     2) Функция DREVERSE - вырабатывает  то  же  значение,  что  и
REVERSE, но разрушает свой аргумент.
     3) Функция NCONC - вырабатывает то же значение, что и APPEND,
но одновременно она заставляет обладать этим значением свой первый
аргумент.
     4) Функция TCONC - помещает значение своего первого аргумента
в конец очереди,  представленной вторым аргументом.  Если эта оче-
редь пуста,  то формируется очередь, состоящая из одного элемента.
Под очередью понимается списочная структура,  состоящая из некото-
рого списка и лисповской ячейки,  содержащей указатели на первый и
последний элементы этого списка.
     5) Функция  EFFACE - значением второго аргумента функции дол-
жен быть список.  Если этот список содержит хотя бы один  элемент,
совпадающий  со значением первого аргумента,  то первый по порядку
из этих элементов исключается из списка, в противном случае список
не  меняется.  Значением  функции является преобразованный список.
Если выброшенный элемент не был самым первым в списке, то значени-
ем второго аргумента также становится преобразованный список.
     6) Функция DREMOVE - в  отличие  от  EFFACE,  выбрасывает  из
списка,  являющегося значением ее второго аргумента, все элементы,
совпадающие со значением первого аргумента функции.
     7) Предикат LCYCLEP - вырабатывает значение Т,  если в значе-
нии аргумента есть цикл по цепочке d-указателей, и NIL в противном
случае,  т.е.  если  в результате многократного применения функции
CDR к значению аргумента можно получить атом.
     8) Предикат  CYCLEP - вырабатывает значение Т,  если значение
аргумента - циклическая списочная структура,  и значение NIL, если
в значении аргумента нет циклов.

                           C) Предикаты

     Предикаты FORALL,  FORSOME, FORODD - у этих предикатов по два
аргумента.  Значением  первого  аргумента  должен  быть  некоторый
список L, а второго (функционального) аргумента - наименование или
определяющее выражение функции Р.
     1) Предикат  FORALL - принимает значение Т лишь в том случае,
если функция Р принимает значение "истина" (т.е.  не NIL) на  всех
элементах списка L.
     2) Предикат FORSOME - принимает значение Т,  если  функция  Р
принимает значение "истина" хотя бы на одном элементе списка L.
     3) Предикат FORODD - принимает значение Т, если число элемен-
тов  списка  L,  на которых функция P принимает значение "истина",
нечетно.
     4) Предикат  ATOMLIST  - проверяет,  является ли его аргумент
списком (возможно, пустым), составленным лишь из атомов.
     5) Предикат LISTP - принимает значение NIL, если заданное вы-
ражение является атомом,  отличным от NIL, или выражением, которое
может  быть  записано только в точечных обозначениях.  В противном
случае заданное выражение  является  списком,  который  можно  за-
писать,  не  прибегая к точечным обозначениям ни на одном из уров-
ней, и предикат принимает значение Т.
     6) Предикат ONELEVEL - проверяет, является ли аргумент одноу-
ровневым списком.

                D) Порядок и упорядочение списков

     1) Предикат ORDER - проверяет,  в каком порядке два  заданных
элемента  встречаются  в  данном  списке.  Список (упорядочивающая
последовательность) задается в качестве значения третьего аргумен-
та функции ORDER.  Если при просмотре элементов этого списка слева
направо встречается элемент,  совпадающий со значением первого ар-
гумента,  а  ни один из ранее просмотренных элементов не совпал со
значением второго аргумента,  то значение предиката  равно  Т,  во
всех остальных случаях оно равно NIL.
     2) Предикат ORDER1 - вычисляется так же, как и ORDER, однако,
если  ни один из заданных элементов не содержится в данном списке,
то в качестве значения предиката выдается атом ORDERUNDEF.
     3) Предикат  LEXORDER  -  сравнивает - элемент за элементом -
два списка,  заданные как значения первого и  второго  аргументов.
Если  в  какой-либо позиции обнаруживаются различные элементы,  то
они сравниваются между собой с помощью предиката ORDER1,  причем в
качестве  третьего  аргумента (упорядочивающей последовательности)
указывается третий аргумент обращения к LEXORDER.  Результат срав-
нения  (T,NIL,ORDERUNDEF)  выдается  в качестве значения предиката
LEXORDER. Eсли раньше, чем встретятся различные элементы, исчерпа-
ется первый список,  то выдается результат Т, если первым исчерпа-
ется второй список, то в качестве результата выдается NIL.
     4) Предикат LEXORDER1 - отличается от LEXORDER тем,  что зна-
чением третьего аргумента для него должен быть список,  каждая по-
зиция которого в свою очередь является списком,  который использу-
ется в случае необходимости для сравнения соответствующих  позиций
списков, заданных в качестве значений первых двух аргументов.
     5) Функция FIRST - среди элементов списка,  заданного  в  ка-
честве  значения первого аргумента,  выбирает тот,  который раньше
встречается в списке,  заданном в качестве значения второго  аргу-
мента.  Если  ни один из элементов первого списка не содержится во
втором, то выбирается первый элемент первого списка.
     6) Функция  RANK - упорядочивает список,  заданный в качестве
ее первого аргумента,  переставляя его элементы в  той  последова-
тельности,  в какой они встречаются в списке, являющемся значением
второго аргумента.

                        E) Поиск в списках

     В этом разделе собраны функции,  выбирающие из списка элемент
или элементы, обладающие заданным свойством. Список задается в ви-
де значения аргумента,  соответствующего связанной  переменной  L,
свойство характеризуется предикатом, наименование или определяющее
выражение которого  дано  в  качестве  значения  аргумента,  соот-
ветствующего связанной (функциональной) переменной Р.
     1) Функция POSSESSING - образует  список  из  всех  элементов
данного списка, обладающих заданным свойством.
     2) Функция SUCHTHAT - выбирает  из  заданного  списка  первый
элемент,  обладающий заданным свойством. Если такого элемента нет,
то вырабатывается значение NIL.
     3) Функция  SUCHTHAT1  -  проверяет,  содержится  ли в данном
списке хотя бы один элемент с заданным свойством.  Если да,  то  в
момент  обнаружения такого элемента в качестве результата принима-
ется значение четвертого аргумента функции SUCHTHAT1. Если нет, то
результатом является значение третьего аргумента.
     4) Функция SUCHTHAT2 -  проверяет,  содержится  ли  в  данном
списке  хотя бы один элемент с заданным свойством.  Если да,  то к
хвосту заданного списка,  начиная с найденного элемента,  применя-
ется функция,  наименование или определяющее выражение которой за-
дано в качестве  значения  третьего  аргумента  (функционального).
Если нет, то вырабатывается значение NIL.
     5) Функция FIRST-COIN - возвращает первый элемент, входящий в
оба списка X и Y, в противном случае - NIL.

                   F) Операции над множествами

     Cписки рассматриваются как множества своих элементов - поряд-
ку элементов в списке не придается значения,  а два или более оди-
наковых  элемента списка рассматриваются как один элемент множест-
ва.
     1) Функция SETOF - для каждого повторяющегося элемента исклю-
чает из списка все вхождения, кроме одного.
     2) Функция MAKESET - делает то же,  что SETOF, но описана че-
рез PROG.  Порядок элементов в результирующем  списке  оказывается
другим.
     3) Функция DIFLIST - вычисляет разность множеств  X\Y.  Иначе
говоря,  она  исключает  из списка,  заданного в качестве значения
первого аргумента функции все элементы,  встречающиеся  в  списке,
представленном значением второго аргумента.
     4) Фукция SUBSET - вычисляет предикат "множество  X  является
подмножеством множества Y".  Иначе говоря, она вырабатывает значе-
ние Т,  если каждый элемент списка,  заданного в качестве  первого
аргумента функции,  содержится в списке,  представленном значением
второго аргумента.
     5) Функция UNION - вычисляет объединение двух множеств.  Зна-
чение функции представляет собой список всех выражений, являющихся
элементами хотя бы одного из заданных списков.  Если каждый из за-
данных списков не содержал повторяющихся элементов, то в результи-
рующий список каждый элемент войдет лишь один раз.
     6) Функция LUNION - объединяет множества, заданные в качестве
элементов списка, являющегося значением аргумента функции.
     7) Функция INTERSECTION -  вычисляет  пересечение  двух  мно-
жеств.  Значением функции является список всех выражений, входящих
элементами в оба заданных списка.  Если каждый из заданных списков
не содержит повторяющихся элементов,  то в результирующемся списке
элементы не будут повторяться.
     8) Предикат   EQUALSET   -  проверяет,  равны  ли  множества,
представленные двумя заданными списками.
     9) Функция CART - образует декартово произведение двух задан-
ных множеств.  Точнее говоря, она формирует лексикографически упо-
рядоченный   список,  элементами  которого  являются  всевозможные
списки,  содержащие по два элемента каждый,  причем первый элемент
берется из первого, а второй - из второго заданного списка.
     10) Предикат SETP - проверяет, является ли список множеством,
т.е. входит ли каждый элемент в список лишь один раз.
     11) Функция SIMDIFF - формирует множество  из  элементов,  не
входящих в оба множества (симметрическая разность множеств).

                     G) Ассоциативные списки

     1) Функция PAIR - объединяет элементы двух заданных списков в
ассоциативный список,  вырабатываемый в качестве значения функции.
Функция не определена, если второй из заданных списков короче пер-
вого.
     2) Функция  DPAIR  -  действует аналогично PAIR,  но значение
первого аргумента заменяется значением функции.
     3) Функция ASSOC - вырабатывает в качестве значения первую по
порядку пару из заданного ассоциативного списка,  у которой первый
элемент совпадает с заданным выражением.  Если такой пары нет,  то
вырабатывается значение NIL.
     4) Функция PAIRLIS - подобна функции PAIR и отличается от нее
лишь тем, что она не создает ассоциативный список, а добавляет но-
вые пары к существующему списку.
     5) Функция SUBST - подставляет в заданное выражение z (в зна-
чение  ее  третьего аргумента) выражение x (значение первого аргу-
мента) вместо всех подвыражений, совпадающих со значением y второ-
го  аргумента  (на какой бы глубине они не находились).  Результат
подстановки выдается в качестве значения функции.
     6) Функция  SUBLIS - в заданном выражении y (значение ее вто-
рого аргумента) заменяет все входящие в него атомы,  которым в за-
данном ассоциативном списке (значение первого аргумента) поставле-
ны в соответствия некоторые выражения, этими выражениями. Преобра-
зованное  выражение выдается в качестве значения функции.  Функция
SUBLIS обращается к функции  SUB2,  которая  для  заданного  атома
(значения второго аргумента) выдает в качестве значения либо выра-
жение,  поставленное ему в соответствие в  заданном  ассоциативном
списке, либо сам этот атом, если такого выражения нет.
     7) Функция SASSOC - подобна функции ASSOC и отличается от нее
тем, что, когда в заданном ассоциативном списке не найдено никако-
го соответствия для заданного выражения, в качестве значения выда-
ется результат обращения к функции (без аргументов),  наименование
или определяющее выражение которой задано в качестве третьего  ар-
гумента функции SASSOC.

                          H) Функционалы

     1) Функция  APL-APPLY  -  применяет  каждую функцию fi списка
f=(f1 f2 ...  fN),  являющегося первым аргументом функции, к соот-
ветствующему элементу xi списка x=(x1 x2 ... xN), являющегося вто-
рым аргументом функции, и возвращает список, сформированный из ре-
зультатов.
     2) Функция MAPLIST - применяет функцию,  заданную в  качестве
ее  второго аргумента (функционального),  последовательно ко всему
списку, заданному в качестве значения первого аргумента, и ко всем
спискам,  поочередно  получаемым отбрасыванием первого элемента от
предыдущего списка.  Значением функции MAPLIST является список по-
лученных результатов.
     3) Функция MAPCAR - подобна функции MAPLIST и  отличается  от
нее  тем,  что заданная функция применяется к первым элементам тех
списков,  к которым  она  применялась  бы  в  случае  обращения  к
MAPLIST.
     4) Функция MAP - имеет смысл,  если функция F, заданная в ка-
честве  ее второго аргумента,  обладает каким-либо побочным эффек-
том.  Эта функция последовательно применяется к тем же аргументам,
что и в случае функции MAPLIST,  но выработанные значения никак не
используются и не сохраняются.  Значение функции MAP равно NIL  (а
если очередной аргумент, подготовленный для обращении к функции F,
окажется атомом, то этому атому).

                        I) Списки свойств

     1) Функция PUTPROP - помещает в список свойств атома, указан-
ного  в  качестве ее первого аргумента,  свойство,  представленное
значением третьего аргумента,  с индикатором, заданным в виде зна-
чения второго аргумента. В качестве результата функция PUTPROP вы-
рабатывает атом, список свойств которого подвергся изменению. Если
в  списке свойств этого атома уже было свойство с данным индикато-
ром, то это свойство замещается новым, индикатор не дублируется.
     2) Функция GETPROP - извлекает из списка свойств данного ато-
ма (значения первого  аргумента)  свойство  с  данным  индикатором
(значением  второго  аргумента).  Если  такого индикатора в списке
свойств нет, то вырабатывается значение NIL.
     3) Функция PROP - отличается от функции GETPROP тем,  что она
выдает в качестве результата не свойство, связанное с данным инди-
катором  (если  оно  есть в списке),  а весь хвост списка свойств,
следующий за найденным индикатором.  Если же  индикатор  в  списке
свойств не обнаруживается, то производится обращение к функции без
аргументов, наименование или определяющее выражение которой должно
быть  задано  в качестве третьего аргумента PROP.  Результат этого
обращения выдается в этом случае в качестве результата обращения к
PROP.
     4) Функция REMPROP - удаляет из списка свойств данного  атома
(значения первого аргумента в обращении к ней) свойство,  снабжен-
ноет данным индикатором (значение  второго  аргумента),  вместе  с
этим  индикатором.  Если  такого  индикатора  не  было,  то список
свойств не меняется.  Значение функции совпадает со значением пер-
вого аргумента.
     5) Функция REMPROPS - удаляет все свойства символа.
     6) Предикат  HASPROP - проверяет,  обладает ли символ (первый
аргумент) данным индикатором (второй аргумент).

          J) Работа с упорядоченными бинарными деревьями

     Упорядоченное бинарное дерево состоит из узлов  вида:
        (<элемент> <левое поддерево> <правое поддерево>).
     В каждом узле выполнено следующее условие:  все  элементы  из
узлов его левого поддерева в некотором урорядочении (например,  по
числовой величине или в алфавитном порядке) предшествуют  элементу
из  узла и соответственно элементы из узлов правого поддерева сле-
дуют за ним. Пример:
              (5 (3 (1 NIL NIL)
                    (4 NIL NIL)
                 (7 (6 NIL NIL)
                    (13 (11 NIL NIL)
                        (15 NIL NIL))))
     1) Функция FINDBT - ищет в дереве данный элемент.
     2) Функция ADDBT - добавляет в дерево данный элемент.  (Заме-
чание:  копируйте дерево по пути поиска и подправляйте нужное под-
дерево).
     3) Функция PREDBT - выделяет в отдельное (упорядоченное)  де-
рево  из  первоначального дерева все узлы,  предшествующие данному
элементу.
     4) Функция  POSTBT - выделяет в отдельное (упорядоченное) де-
рево из первоначального дерева все узлы,  следующие за данным эле-
ментом.
     5) Функция UNIONBT - объединяет два  упорядоченных  дерева  в
одно  общее  упорядоченное дерево (Замечание:  используйте функции
PREDBT и POSTBT).

             K) Разные процедуры формирования списков

     1) Функция BULB (ЛУКОВИЦА)  -  строит  N-уровневый  вложенный
список, элементом которого на самом глубоком уровне является N.
     2) Функция FACT - результатом является выражение,  являющееся
факториалом числа, в котором числа (сомножители) упорядочены в по-
рядке возрастания.
     3) Функция  FIBON  - порождает последовательность чисел Фибо-
наччи. Числа Фибоначчи определяются следающим рекуррентным соотно-
шением: F(n+1)=F(n)+F(n-1), при F(0)=1, F(1)=2.
     4) Функция INTERPR - преобразует  инфиксную  запись  операций
выражения в префиксную и возвращает значение выражения.

                       КОНТРОЛЬНЫЕ ВОПРОСЫ

     1. Чем отличаются символы от атомов в языке Лисп ?
     2. В каких случаях выдается ошибка при попытке  интерпретиро-
вать S-выражение ?
     3. Перечислите базовые функции языка Лисп. Каковы типы их ар-
гументов, и какие значения они возвращают в качестве результата ?
     4. Вычислите значения следующих выражений:
        a) '(CAR '(A B C))
        б) (EVAL '(CAR '(A B C)))
        с) (EVAL (CAR '(A B C)))
        д) (EVAL (QUOTE (QUOTE QUOTE)))
        е) (QUOTE (EVAL (QUOTE (QUOTE QUOTE))))
     5. Каково будет значение атома A после следующих вызовов:
        a) (SET (SETQ A 'A) 'B)
        б) (SET (SETQ B 'A)(SETQ A 'C))
           (SET B A)
     6. Какое значение возвращает функция COND ?
     7. Какое условие должно стоять первым в определении рекурсив-
ной функции ?
     8. Назовите функции с побочными эффектами.  В чем заключается
этот эффект ?
     9. Определите средства,  порядок тестирования и отладки функ-
ций, реализующих пересечение двух множеств, описанных выше.


