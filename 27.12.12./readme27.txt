__________

Введение
__________

Функция, которая принимает число n и возвращает функцию,
которая добавляет n к своему аргументу:
(лексические замыкания)

(defun addn (n)
  #’(lambda (x)
      (+ x n)))

__________

Форма
__________

Вычисление:

специальный оператор quote

> (quote (+ 3 5))
(+ 3 5)

quote берет один аргумент и возвращает его текстовую запись

аналогично, сокращение quote

> ’(+ 3 5)
(+ 3 5)


Данные:

integer - целое число 256
строка - последовательность символов в кавычках
"изучать Лисп это как мотокросс"

символы - слова, преобразуются к верхнему регистру

> ’Artichoke
ARTICHOKE


списки - последовательность из нуля и более элементов,
заключенных в скобки (любой тип, другой список)

чтобы Лисп не счел список вызовом функции
его нужно процитировать

> ’(my 3 "Sons")
(MY 3 "Sons")
> ’(the list (a b c) has 3 elements)
(THE LIST (A B C) HAS 3 ELEMENTS)


функция list
пример,
внутри вызова функции list вычисляется
значение функции +

> (list ’my (+ 2 1) "Sons")
(MY 3 "Sons")


цитирование есть в коде,
тогда нет вычисления, возвращается сама текстовая запись
цитирования нет - производится вычисление, и на входе
дается результат вычисления

> (list ’(+ 2 1) (+ 2 1))
((+ 2 1) 3)

пустой список

> ()
NIL
> nil
NIL




Операции со списками:

построение списков - cons

> (cons ’a ’(b c d))
(A B C D)

> (cons ’a (cons ’b nil))
(A B)

более удобно в данном случае использовать list
> (list ’a ’b)
(A B)


функции для получения элементов списка

car

> (car ’(a b c))
A

cdr

> (cdr ’(a b c))
(B C)


комбинирование car и cdr

> (car (cdr (cdr ’(a b c d))))
C

аналогично, но с помощью функции third

> (third ’(a b c d))
C


Истинность:

истинность - символ t

функция listp возвращает истину, если ее аргумент - список

> (listp ’(a b c))
T

ложь - nil

функция listp вернет ложь, если ее аргумент - НЕ список

> (listp 27)
NIL


условный оператор if
три аргумента:
test
then
else

> (if (listp ’(a b c))
(+ 1 2)
(+ 5 6))
3
> (if (listp 27)
(+ 1 2)
(+ 5 6))
11


истина - символ t
но и все остальное, если это НЕ nil - считается за истину

> (if 27 1 2)
1
истина


логические операторы and и or

> (and t (+ 1 2))
3


Функции:

новые функции можно определить с помощью оператора defun

> (defun our-third (x)
(car (cdr (cdr x))))
OUR-THIRD

далее идет вызов функции, в нашем случае имя функции our-third,

> (our-third ’(a b c d))
C


выражение проверяет, превосходит ли сумма
чисел 1 и 4 чсило 3

> (> (+ 1 4) 3)
T

заменим конкретные числа, переменными
получим функцию, которая делает тоже самое,
что и предыдущее выражение, но для многих чисел

> (defun sum-greater (x y z)
(> (+ x y) z))
SUM-GREATER
> (sum-greater 1 4 3)
T



Рекурсия:

функция вызывающая саму себя и другие функции

