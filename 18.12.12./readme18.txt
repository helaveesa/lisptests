продолжение

лисп

списки

CL-USER> (defun out-listp (x)
           (or (null x) (consp x)))
OUT-LISTP
CL-USER> (defun our-atom (x) (not (consp x)))
OUR-ATOM
проверка, является ли объект cons-ячейкой

______________
функция nthcdr
______________
возвращает n-ый хвост списка

CL-USER> (nthcdr 2 '(a b c))
cdr - это хвост списка (a b c) то есть (b c)
я запрашиваю хвост списка начиная со второго элемента списка
вот и получается, что если рассмотреть список (b c),
то b-1-ый элемент хвоста списка  c-2-ой элемент хвоста списка
вот машина и вернула мне (С)
(C)

все следующие примеры, аналогично

CL-USER> (nthcdr 1 '(a b c))
(B C)

CL-USER> (nthcdr 3 '(a b c d e f))
в данном случае,хвост списка это (b c d e f),
а мне нужно вернуть хвост списка начиная с 3-его элемента,
3-ий элемент списка (b c d e f) - это d,
следовательно вот результат:
(D E F)

CL-USER> (nthcdr 3 '(a b c d))
в данном случае, все тоже самое,
хвост списка (b c d),
мне нужно вернуть список, начиная с 3-его элемента,
b-1
c-2
d-3,
т.к. d-3, а после него идет nil,
результат будет таким
(D)
то, есть список из одного элемента


CL-USER> (nthcdr 3 '(a b c))
и снова аналогично, хвост списка (b c),
мне нужен 3-ий элемент хвоста списка,
за хвостом списка (b c) следует nil,
следовательно, вот такой результат:
NIL

CL-USER> (nthcdr 4 '(a b c))
NIL

CL-USER> (nthcdr 3 '(a b c d))
(D)

CL-USER> (nthcdr 4 '(a b c d))
NIL

CL-USER> (nthcdr 4 '(a b c d e f g t))
(E F G T)


**************************************************

упражнения стр 71

1 упражнение
надо еще думать

2 упр

напишите свой вариант функции union,
который сохраняет порядок следования элементов согласно исходным
спискам

исхдные данные:

(new-union ’(a b c) ’(b a d))
(A B C D)

функция union - это функция объединения
(тема множества)

функция работает ровно с двумя списками
и имеет аргументы по ключу :test и :key



